"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const initDebug = require("debug");
const FileType = require("file-type");
const Token = require("token-types");
const Util_1 = require("../common/Util");
const FourCC_1 = require("../common/FourCC");
const BasicParser_1 = require("../common/BasicParser");
const debug = initDebug("music-metadata:parser:APEv2");
var DataType;
(function (DataType) {
    DataType[DataType["text_utf8"] = 0] = "text_utf8";
    DataType[DataType["binary"] = 1] = "binary";
    DataType[DataType["external_info"] = 2] = "external_info";
    DataType[DataType["reserved"] = 3] = "reserved";
})(DataType || (DataType = {}));
const tagFormat = 'APEv2';
class Structure {
    static parseTagFlags(flags) {
        return {
            containsHeader: Structure.isBitSet(flags, 31),
            containsFooter: Structure.isBitSet(flags, 30),
            isHeader: Structure.isBitSet(flags, 31),
            readOnly: Structure.isBitSet(flags, 0),
            dataType: (flags & 6) >> 1
        };
    }
    /**
     * @param num {number}
     * @param bit 0 is least significant bit (LSB)
     * @return {boolean} true if bit is 1; otherwise false
     */
    static isBitSet(num, bit) {
        return (num & 1 << bit) !== 0;
    }
}
/**
 * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum
 */
Structure.DescriptorParser = {
    len: 52,
    get: (buf, off) => {
        return {
            // should equal 'MAC '
            ID: FourCC_1.FourCcToken.get(buf, off),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            version: Token.UINT32_LE.get(buf, off + 4) / 1000,
            // the number of descriptor bytes (allows later expansion of this header)
            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),
            // the number of header APE_HEADER bytes
            headerBytes: Token.UINT32_LE.get(buf, off + 12),
            // the number of header APE_HEADER bytes
            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),
            // the number of header data bytes (from original file)
            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),
            // the number of bytes of APE frame data
            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),
            // the high order number of APE frame data bytes
            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),
            // the terminating data of the file (not including tag data)
            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),
            // the MD5 hash of the file (see notes for usage... it's a littly tricky)
            fileMD5: new Token.BufferType(16).get(buf, off + 36)
        };
    }
};
/**
 * APE_HEADER: describes all of the necessary information about the APE file
 */
Structure.Header = {
    len: 24,
    get: (buf, off) => {
        return {
            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
            compressionLevel: Token.UINT16_LE.get(buf, off),
            // any format flags (for future use)
            formatFlags: Token.UINT16_LE.get(buf, off + 2),
            // the number of audio blocks in one frame
            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),
            // the number of audio blocks in the final frame
            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),
            // the total number of frames
            totalFrames: Token.UINT32_LE.get(buf, off + 12),
            // the bits per sample (typically 16)
            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),
            // the number of channels (1 or 2)
            channel: Token.UINT16_LE.get(buf, off + 18),
            // the sample rate (typically 44100)
            sampleRate: Token.UINT32_LE.get(buf, off + 20)
        };
    }
};
/**
 * TAG: describes all the properties of the file [optional]
 */
Structure.TagFooter = {
    len: 32,
    get: (buf, off) => {
        return {
            // should equal 'APETAGEX'
            ID: new Token.StringType(8, "ascii").get(buf, off),
            // equals CURRENT_APE_TAG_VERSION
            version: Token.UINT32_LE.get(buf, off + 8),
            // the complete size of the tag, including this footer (excludes header)
            size: Token.UINT32_LE.get(buf, off + 12),
            // the number of fields in the tag
            fields: Token.UINT32_LE.get(buf, off + 16),
            // reserved for later use (must be zero)
            reserved: new Token.BufferType(12).get(buf, off + 20) // ToDo: what is this???
        };
    }
};
Structure.TagField = footer => {
    return new Token.BufferType(footer.size - Structure.TagFooter.len);
};
class APEv2Parser extends BasicParser_1.BasicParser {
    constructor() {
        super(...arguments);
        this.type = "APEv2"; // ToDo: versionIndex should be made dynamic, APE may also contain ID3
        this.ape = {};
    }
    /**
     * Calculate the media file duration
     * @param ah ApeHeader
     * @return {number} duration in seconds
     */
    static calculateDuration(ah) {
        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
        duration += ah.finalFrameBlocks;
        return duration / ah.sampleRate;
    }
    static parseFooter(metadata, tokenizer, options) {
        return tokenizer.readToken(Structure.TagFooter).then(footer => {
            if (footer.ID !== "APETAGEX") {
                throw new Error("Expected footer to start with APETAGEX ");
            }
            return tokenizer.readToken(Structure.TagField(footer)).then(tags => {
                return APEv2Parser.parseTags(metadata, footer, tags, !options.skipCovers);
            });
        });
    }
    // ToDo: public ???
    static parseTags(metadata, footer, buffer, includeCovers) {
        let offset = 0;
        for (let i = 0; i < footer.fields; i++) {
            const size = Token.UINT32_LE.get(buffer, offset);
            offset += 4;
            const flags = Structure.parseTagFlags(Token.UINT32_LE.get(buffer, offset));
            offset += 4;
            let zero = Util_1.default.findZero(buffer, offset, buffer.length);
            const key = buffer.toString("ascii", offset, zero);
            offset = zero + 1;
            switch (flags.dataType) {
                case DataType.text_utf8: { // utf-8 textstring
                    const value = buffer.toString("utf8", offset, offset += size);
                    const values = value.split(/\x00/g);
                    /*jshint loopfunc:true */
                    for (const val of values) {
                        metadata.addTag(tagFormat, key, val);
                    }
                    break;
                }
                case DataType.binary: // binary (probably artwork)
                    if (includeCovers) {
                        const picData = buffer.slice(offset, offset + size);
                        let off = 0;
                        zero = Util_1.default.findZero(picData, off, picData.length);
                        const description = picData.toString("utf8", off, zero);
                        off = zero + 1;
                        const data = Buffer.from(picData.slice(off));
                        const fileType = FileType(data);
                        if (fileType) {
                            if (fileType.mime.indexOf('image/') === 0) {
                                const picture = {
                                    description,
                                    data,
                                    format: fileType.mime
                                };
                                offset += size;
                                metadata.addTag(tagFormat, key, picture);
                            }
                            else {
                                debug('Unexpected binary tag of type ' + fileType.mime);
                            }
                        }
                        else {
                            debug('Failed to determine file type for binary tag: ' + key);
                        }
                    }
                    break;
                default:
                    throw new Error("Unexpected data-type: " + flags.dataType);
            }
        }
    }
    parse() {
        return this.tokenizer.readToken(Structure.DescriptorParser)
            .then(descriptor => {
            if (descriptor.ID !== "MAC ") {
                throw new Error("Expected MAC on beginning of file"); // ToDo: strip/parse JUNK
            }
            this.ape.descriptor = descriptor;
            const lenExp = descriptor.descriptorBytes - Structure.DescriptorParser.len;
            if (lenExp > 0) {
                return this.parseDescriptorExpansion(lenExp);
            }
            else {
                return this.parseHeader();
            }
        }).then(header => {
            return this.tokenizer.readToken(new Token.IgnoreType(header.forwardBytes)).then(() => {
                return APEv2Parser.parseFooter(this.metadata, this.tokenizer, this.options);
            });
        });
    }
    parseDescriptorExpansion(lenExp) {
        return this.tokenizer.readToken(new Token.IgnoreType(lenExp)).then(() => {
            return this.parseHeader();
        });
    }
    parseHeader() {
        return this.tokenizer.readToken(Structure.Header).then(header => {
            // ToDo before
            this.metadata.setFormat('lossless', true);
            this.metadata.setFormat('dataformat', "Monkey's Audio");
            this.metadata.setFormat('bitsPerSample', header.bitsPerSample);
            this.metadata.setFormat('sampleRate', header.sampleRate);
            this.metadata.setFormat('numberOfChannels', header.channel);
            this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));
            return {
                forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +
                    this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
            };
        });
    }
}
exports.APEv2Parser = APEv2Parser;
